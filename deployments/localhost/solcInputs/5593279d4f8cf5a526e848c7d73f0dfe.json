{
  "language": "Solidity",
  "sources": {
    "contracts/Buttar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nerror OnlyOwnerError();\nerror NotEnoughLiquidity();\nerror ItemOutofStock();\nerror OutOfStock();\nerror QuantityNotAvailble();\nerror OnlySellerCanStopSell();\nerror OnlyBuyerCanCancel();\nerror TransferFailed();\nerror OrderCannotCanceled();\nerror AlreadySeller();\nerror SellerNotAvailble();\nerror SellerIsBlocked();\nerror OrderCannotDelivered();\nerror OrderCannotRecieved();\nerror NotEnoughMoney();\n\ncontract Buttar {\n\n    enum itemState {\n        Availble,\n        OutofStock\n    }\n    enum orderState {\n        Placed,\n        Delivered,\n        Closed,\n        Canceled,\n        Recieved\n    }\n    enum sellerState {\n        Open,\n        Block\n    }\n\n    struct Product {\n        // uint256 productId;\n        address productHash;\n        uint256 productPrice;\n        address sellerId;\n        itemState state;\n    }\n\n    struct Order {\n        address buyer;\n        uint256 bill;\n        uint256[] productList;\n        uint256[] productQuantityList;\n        orderState state;\n    }\n\n    struct Seller {\n        uint256 sellerAmount;\n        uint256 sellerTotalLiquidity;\n        uint256 sellerAvailbleLiquidity;\n        sellerState state;\n    }\n\n    address public immutable i_owner;\n\n    Product[] product;\n    // mapping (address => product) product;\n    //productId to Product\n    mapping (uint256 => Product) products;\n    mapping (uint256 => uint256) productQuantity;\n\n    Seller[] sellers;\n    mapping (address => Seller) seller;\n    mapping(address => bool) isSeller;\n\n    address[] buyer;\n    mapping (address => uint256[]) buyerCart;\n    mapping (address => uint256) buyerBill;\n    mapping (address => mapping (uint256 => uint256) ) buyerProductQuantity;\n\n    Order[] orders;\n    //orderId to Order\n    mapping (uint256 => Order) order;\n    mapping (uint256 => address) orderBuyerAddress;\n\n    uint256 Liquidity;\n    uint256 currentProductId;\n    uint256 currentOrderId;\n\n    uint256 TotalContractAssests;\n\n    event SellerAdded(address indexed sellerAddress);\n    event LiquidityProvided(address indexed selleAddress, uint256 liquidityAmount);\n\n    event ProductAdded(uint256 indexed productId, uint256 productPrice, uint256 productAmount);\n    event OrderPlaced(uint256 indexed OrderId, uint256[] productList, uint256[] productQunatity, uint256 bill);\n    event OrderDeliverd(uint256 indexed OrderId);\n    event OrderRecieved(uint256 indexed OrderId);\n    event OrderCanceled(uint256 indexed OrderId);\n\n    event SellerBlocked(address indexed sellerAddress);\n\n    modifier onlyOwner {\n        // require(msg.sender == i_owner, OnlyOwnerError);\n        _;\n    }\n\n    constructor() {\n        i_owner = msg.sender;\n        Liquidity = 0;\n        currentProductId = 0;\n        currentOrderId = 0;\n        TotalContractAssests = 0;\n    }\n\n    function becomeSeller() public payable {\n        if(isSeller[msg.sender]) {\n            revert AlreadySeller();\n        }\n        // sellers.push(payable(msg.sender));\n        \n        Seller memory newSeller;\n        newSeller.sellerAmount = 0;\n        newSeller.sellerTotalLiquidity = 0;\n        newSeller.sellerAvailbleLiquidity = 0;\n        newSeller.state = sellerState(0);\n// \n        sellers.push(newSeller);\n        seller[msg.sender] = newSeller;\n        isSeller[msg.sender] = true;\n        provideLiquid(msg.sender);\n\n        emit SellerAdded(msg.sender);\n    }\n\n    function provideLiquid(address _seller) public payable {\n        if(!isSeller[_seller]){\n            revert SellerNotAvailble();\n        }\n        if(seller[_seller].state == sellerState(1)){\n            revert SellerIsBlocked();\n        }\n        seller[_seller].sellerTotalLiquidity += msg.value;\n        seller[_seller].sellerAvailbleLiquidity = seller[_seller].sellerTotalLiquidity - 1000 wei;\n        Liquidity += msg.value;\n\n        emit LiquidityProvided(msg.sender, msg.value);\n    }\n\n    function sell(address _productHash, uint256 _productPrice, uint256 _productQuantity) public {\n        if(seller[msg.sender].sellerAvailbleLiquidity < _productPrice * _productQuantity){\n            revert NotEnoughLiquidity();\n        }\n        if(seller[msg.sender].state == sellerState(1)){\n            revert SellerIsBlocked();\n        }\n        Product memory newProduct;\n        newProduct.productHash = _productHash;\n        newProduct.productPrice = _productPrice;\n        newProduct.sellerId = msg.sender;\n        newProduct.state = itemState(0);\n\n        products[currentProductId] = newProduct;\n        productQuantity[currentProductId] = _productQuantity;\n        seller[msg.sender].sellerAvailbleLiquidity -= _productPrice * _productQuantity;\n\n        product.push(newProduct);\n\n        emit ProductAdded(currentProductId, _productPrice, _productQuantity);\n        currentProductId++;\n    }\n\n    function purchase(uint256[] memory _id, uint256[] memory _quantity) public payable {\n        uint256 bill = 0 wei;\n        for (uint i = 0; i < _id.length; i++) {\n            if(products[i].state == itemState(1)){\n                revert OutOfStock();\n            }\n            if(productQuantity[_id[i]] < _quantity[i]) {\n                revert QuantityNotAvailble();\n            }\n            bill += products[i].productPrice * _quantity[i];\n        }\n        if(bill > msg.value) {\n            revert NotEnoughMoney();\n        }\n        buyer.push(payable(msg.sender));\n        Order memory newOrder;\n        newOrder.buyer = msg.sender;\n        newOrder.bill = bill;\n        newOrder.productList = _id;\n        newOrder.productQuantityList = _quantity;\n        orders.push(newOrder);\n        order[currentOrderId] = newOrder;\n        orderBuyerAddress[currentOrderId] = msg.sender;\n\n        orders.push(newOrder);\n        if(msg.value > bill) {\n            (bool success, ) = msg.sender.call{ value: msg.value - bill}(\"\");\n            if(!success) {\n                revert TransferFailed();\n            }\n        }\n\n        emit OrderPlaced(currentOrderId, _id, _quantity, bill);\n        currentOrderId++;\n    }\n\n    function stopSell(uint256 _id) public {\n        if(products[_id].sellerId != msg.sender) {\n            revert OnlySellerCanStopSell();\n        }\n        products[_id].state = itemState(1);\n    }\n\n    function deliverOrder(uint256 _id) public {\n        if(order[_id].state != orderState(0)) {\n            revert OrderCannotDelivered();\n        }\n        order[_id].state = orderState(1);\n\n        emit OrderDeliverd(_id);\n    }\n\n    function recieveOrder(uint256 _id) public {\n        if(order[_id].state != orderState(1)) {\n            revert OrderCannotRecieved();\n        }\n        Order memory myOrder = order[_id];\n        uint256 myPrice = 0;\n        for (uint i = 0; i < myOrder.productList.length; i++) {\n            myPrice=0;\n            productQuantity[myOrder.productList[i]] -= myOrder.productQuantityList[i];\n            if(productQuantity[myOrder.productList[i]] == 0) {\n                products[myOrder.productList[i]].state = itemState(1);\n            }\n            myPrice =  products[myOrder.productList[i]].productPrice * myOrder.productQuantityList[i];\n            seller[products[myOrder.productList[i]].sellerId].sellerAmount += myPrice;\n            seller[products[myOrder.productList[i]].sellerId].sellerAvailbleLiquidity += products[myOrder.productList[i]].productPrice * myOrder.productQuantityList[i];\n        }\n        myOrder.state = orderState(4);\n\n        emit OrderRecieved(_id);\n    }\n\n    function cancelOrder(uint256 _id) public {\n        if(orderBuyerAddress[_id] != msg.sender) {\n            revert OnlyBuyerCanCancel();\n        }\n        // if(order[_id].state != orderState(0) || order[_id].state != orderState(1)){\n        //     revert OrderCannotCanceled();\n        // }\n        order[_id].state = orderState(3);\n        returnBuyer(_id);\n\n        emit OrderCanceled(_id);\n    }\n\n    function paySeller(address _seller) public payable onlyOwner {\n        (bool success, ) = _seller.call{ value: seller[msg.sender].sellerAmount}(\"\");\n        if(!success) {\n            revert TransferFailed();\n        }\n        seller[_seller].sellerAmount = 0;\n    }\n\n    function returnBuyer(uint256 _id) internal {\n        (bool success, ) = msg.sender.call{ value: order[_id].bill }(\"\");\n        if(!success) {\n            revert TransferFailed();\n        }\n        order[_id].bill = 0;\n    }\n\n    function blockSeller(address _seller) public onlyOwner {\n        seller[_seller].state = sellerState(1);\n    }\n\n    //pure functions\n    // function calculateLiquidityLimit(int256 _amount) internal pure returns(int256) {\n        // int256 liquid;\n\n        // sellerAvailbleLiquidity[_seller] += _amount;\n    // }\n\n    //getters\n    function getTotalContractBalance() public view returns(uint256) {\n        return address(this).balance;\n    }\n    function getTotalLiquidity() public view returns(uint256) {\n        return Liquidity;\n    }\n    function getSellerTotalLiquidity(address _seller) public view returns(uint256) {\n        return seller[_seller].sellerTotalLiquidity;\n    }\n    function getSellerAvailbleLiquidity(address _seller) public view returns(uint256) {\n        return seller[_seller].sellerAvailbleLiquidity;\n    }\n    function getCurrentProductId() public view returns(uint256) {\n        return currentProductId;\n    }\n    function getCurrentOrderId() public view returns(uint256) {\n        return currentOrderId;\n    }\n    function getTotalContractAssets() public view returns(uint256) {\n        return address(this).balance;\n    }\n    function getProductHash(uint256 _id) public view returns(address) {\n        return products[_id].productHash;\n    }\n    function getProductState(uint256 _id) public view returns(itemState) {\n        return products[_id].state;\n    }\n    function getProductQuantity(uint256 _id) public view returns(uint256) {\n        return productQuantity[_id];\n    }\n\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}